// Controllers/TimetableController.cs
using KawsayApiMockup.Data;
using KawsayApiMockup.DTOs;
using KawsayApiMockup.Entities; // Import Entities
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore; // Import EF Core namespace
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks; // Use async methods

namespace KawsayApiMockup.Controllers
{
    [ApiController]
    [Route("kawsay/[controller]")]
    public class TimetableController : ControllerBase
    {
        private readonly KawsayDbContext _context; // Inject DbContext

        public TimetableController(KawsayDbContext context)
        {
            _context = context;
        }

        [HttpPost] // POST /kawsay/timetable
        public async Task<ActionResult<TimetableStructure>> CreateTimetable([FromBody] CreateTimetableRequest request)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }
            if (string.IsNullOrWhiteSpace(request.Name))
            {
                 return BadRequest(new { message = "Timetable name is required." });
            }
             if (request.Days == null || request.Days.Count == 0)
             {
                  return BadRequest(new { message = "At least one day is required." });
             }
              if (request.Periods == null || request.Periods.Count == 0)
             {
                  return BadRequest(new { message = "At least one period is required." });
             }

            // Map request DTO to Entity
            var timetableEntity = new TimetableEntity
            {
                Name = request.Name,
                Days = request.Days.Select(d => new TimetableDayEntity { Name = d }).ToList(), // IDs will be generated by DB
                Periods = request.Periods.Select(p => new TimetablePeriodEntity { Start = p.Start, End = p.End }).ToList() // IDs will be generated by DB
            };

            // Add to context and save
            _context.Timetables.Add(timetableEntity);
            await _context.SaveChangesAsync(); // Saves Timetable, Days, and Periods

            // Map created Entity back to response DTO (TimetableStructure)
            var createdTimetableDto = new TimetableStructure
            {
                Id = timetableEntity.Id,
                Name = timetableEntity.Name,
                Days = timetableEntity.Days.Select(d => new DTOs.TimetableDay { Id = d.Id, Name = d.Name }).ToList(),
                Periods = timetableEntity.Periods.Select(p => new DTOs.TimetablePeriod { Id = p.Id, Start = p.Start, End = p.End }).ToList()
            };


            return CreatedAtAction(nameof(GetTimetable), new { id = createdTimetableDto.Id }, createdTimetableDto);
        }

        [HttpGet("{id}")] // GET /kawsay/timetable/{id}
        public async Task<ActionResult<TimetableStructure>> GetTimetable(int id)
        {
            // Fetch entity including related Days and Periods
            var timetable = await _context.Timetables
                                          .Include(t => t.Days)
                                          .Include(t => t.Periods)
                                          .Where(t => t.Id == id)
                                          .FirstOrDefaultAsync();

            if (timetable == null)
            {
                return NotFound();
            }

            // Map entity to DTO
            var timetableDto = new TimetableStructure
            {
                 Id = timetable.Id,
                 Name = timetable.Name,
                 Days = timetable.Days.Select(d => new DTOs.TimetableDay { Id = d.Id, Name = d.Name }).ToList(),
                 Periods = timetable.Periods.Select(p => new DTOs.TimetablePeriod { Id = p.Id, Start = p.Start, End = p.End }).ToList()
            };

            return Ok(timetableDto);
        }

        [HttpGet] // GET /kawsay/timetables (List endpoint)
        [Route("/kawsay/timetables")] // Explicitly set route to /kawsay/timetables
        public async Task<ActionResult<IEnumerable<TimetableStructure>>> GetTimetables()
        {
            // Fetch entities and map to DTOs
            // Note: For listing, we don't necessarily need to Include Days/Periods
            var timetables = await _context.Timetables
                                           .Select(t => new TimetableStructure { Id = t.Id, Name = t.Name }) // Only map essential fields for list
                                           .ToListAsync();
            return Ok(timetables);
        }

        // Added for API completeness, not used by current frontend
        [HttpPut("{id}")] // PUT /kawsay/timetable/{id}
        public async Task<ActionResult<TimetableStructure>> UpdateTimetable(int id, [FromBody] UpdateTimetableRequest request)
        {
            if (id != request.Id)
            {
                return BadRequest(new { message = "ID in URL and body must match." });
            }
             if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }
             if (string.IsNullOrWhiteSpace(request.Name))
            {
                 return BadRequest(new { message = "Timetable name is required." });
            }
             if (request.Days == null || request.Days.Count == 0)
             {
                  return BadRequest(new { message = "At least one day is required." });
             }
              if (request.Periods == null || request.Periods.Count == 0)
             {
                  return BadRequest(new { message = "At least one period is required." });
             }

            var timetableEntity = await _context.Timetables
                                                .Include(t => t.Days) // Include related entities to manage them
                                                .Include(t => t.Periods)
                                                .Where(t => t.Id == id)
                                                .FirstOrDefaultAsync();

            if (timetableEntity == null)
            {
                return NotFound();
            }

            // Apply updates
            timetableEntity.Name = request.Name;

            // Simple approach for updating nested collections: remove existing, add new
            _context.TimetableDays.RemoveRange(timetableEntity.Days);
            _context.TimetablePeriods.RemoveRange(timetableEntity.Periods);

            timetableEntity.Days = request.Days.Select(d => new TimetableDayEntity { Name = d }).ToList();
            timetableEntity.Periods = request.Periods.Select(p => new TimetablePeriodEntity { Start = p.Start, End = p.End }).ToList();

            await _context.SaveChangesAsync(); // Saves changes and adds new related entities

            // Re-fetch or map the updated entity to DTO
             var updatedTimetableDto = new TimetableStructure
            {
                 Id = timetableEntity.Id,
                 Name = timetableEntity.Name,
                 Days = timetableEntity.Days.Select(d => new DTOs.TimetableDay { Id = d.Id, Name = d.Name }).ToList(),
                 Periods = timetableEntity.Periods.Select(p => new DTOs.TimetablePeriod { Id = p.Id, Start = p.Start, End = p.End }).ToList()
            };

            return Ok(updatedTimetableDto);
        }

        // Added for API completeness, not used by current frontend
        [HttpDelete("{id}")] // DELETE /kawsay/timetable/{id}
        public async Task<IActionResult> DeleteTimetable(int id)
        {
            var timetable = await _context.Timetables.FindAsync(id); // Find by primary key
            if (timetable == null)
            {
                return NotFound();
            }

            _context.Timetables.Remove(timetable);
            await _context.SaveChangesAsync(); // Cascade delete handled by OnModelCreating

            return NoContent(); // 204 No Content
        }
    }
}
